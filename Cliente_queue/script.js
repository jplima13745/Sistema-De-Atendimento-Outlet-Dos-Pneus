import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getFirestore, collection, onSnapshot, query, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

// --- Configuração do Firebase (copiada do auth.js) ---
const LOCAL_FIREBASE_CONFIG = {
    apiKey: "AIzaSyDleQ5Y1-o7Uoo3zOXKIm35KljdxJuxvWo",
    authDomain: "banco-de-dados-outlet2-0.firebaseapp.com",
    projectId: "banco-de-dados-outlet2-0",
    storageBucket: "banco-de-dados-outlet2-0.firebasestorage.app",
    messagingSenderId: "917605669915",
    appId: "1:917605669915:web:6a9ee233227cfd250bacbe",
    measurementId: "G-5SZ5F2WKXD"
};

const app = initializeApp(LOCAL_FIREBASE_CONFIG);
const db = getFirestore(app);
const auth = getAuth(app);

// --- Constantes ---
const APP_ID = 'local-autocenter-app';
const CLIENT_ROLE = 'cliente';
const SERVICE_COLLECTION_PATH = `/artifacts/${APP_ID}/public/data/serviceJobs`;
const ALIGNMENT_COLLECTION_PATH = `/artifacts/${APP_ID}/public/data/alignmentQueue`;

// Status do Sistema Operacional
const STATUS_PENDING = 'Pendente';
const STATUS_READY = 'Pronto para Pagamento';
const STATUS_GS_FINISHED = 'Serviço Geral Concluído';

// Status do Alinhamento
const STATUS_WAITING_GS = 'Aguardando Serviço Geral';
const STATUS_WAITING = 'Aguardando';
const STATUS_ATTENDING = 'Em Atendimento';

// --- Estado Global ---
let serviceJobs = [];
let alignmentQueue = [];
let ads = []; // NOVO: Armazena a lista de anúncios

// --- Estado do Auto-Scroll ---
let scrollTimeout = null;
let scrollInterval = null;
const SCROLL_WAIT_AT_TOP = 30 * 1000; // 30 segundos
const SCROLL_SPEED = 50; // Intervalo de atualização (mais rápido para suavidade)
const SCROLL_STEP = 1; // Pixels por passo (menor para ser mais suave)

// --- NOVO: Estado do Ciclo de Anúncios (RF005) ---
const API_BASE_URL = 'https://marketing-api.lucasscosilva.workers.dev'; // URL da API de Marketing
let adCycleTimeout = null; 
let adDisplayTimeout = null; // NOVO: Timer para a duração da exibição do anúncio
let currentAdIndex = 0;
const CYCLE_INTERVAL = 30 * 1000; // 30 segundos para cada etapa (fila ou anúncio)
const readyAlert = document.getElementById('ready-alert');


// --- Gerenciamento de Exibição (Fila vs Anúncios) ---
const queueContainer = document.getElementById('queue-container');
const adContainer = document.getElementById('ad-container');

/**
 * NOVO: Importa a função de login anônimo do Firebase.
 */
import { signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

/**
/**
 * NOVO: Aguarda a confirmação da sessão anônima do Firebase antes de iniciar os listeners.
 * Isso resolve o problema de permissão que ocorria antes.
 */
function waitForFirebaseAuth() {
    onAuthStateChanged(auth, (user) => {
        if (user) { // Usuário anônimo está logado
            console.log("Usuário anônimo autenticado com sucesso no Firebase.");
            initializeSystem();
        } else {
            // Se não houver usuário, tenta fazer o login anônimo.
            console.log("Nenhum usuário. Tentando login anônimo...");
            signInAnonymously(auth).catch(error => console.error("Falha no login anônimo:", error));
        }
    });
}

/**
 * Inicia os listeners do Firestore e outras funcionalidades do sistema.
 */
function initializeSystem() {
    setupClock();
    setupRealtimeListeners();
    fetchAds(); // Busca os anúncios da API
    startAdCycle(); // Inicia o ciclo de exibição de anúncios
}

/**
 * Configura um relógio em tempo real no cabeçalho.
 */
function setupClock() {
    const clockElement = document.getElementById('datetime-display');
    if (!clockElement) return;

    function updateClock() {
        const now = new Date();
        const options = { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' };
        const dateString = now.toLocaleDateString('pt-BR', options);
        const timeString = now.toLocaleTimeString('pt-BR');
        clockElement.textContent = `${dateString.replace(/\.$/, '')} | ${timeString}`; // Remove o ponto final do "short" weekday
    }

    updateClock();
    setInterval(updateClock, 1000); // Atualiza a cada segundo
}

/**
 * Configura os listeners para ouvir as coleções do Firestore em tempo real. (RF001)
 */
function setupRealtimeListeners() {
    const serviceQuery = query(
        collection(db, SERVICE_COLLECTION_PATH),
        where('status', 'in', [STATUS_PENDING, STATUS_READY, STATUS_GS_FINISHED])
    );

    onSnapshot(serviceQuery, (snapshot) => {
        serviceJobs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        renderDisplay();
    }, (error) => {
        console.error("Erro ao ouvir serviços:", error);
        document.getElementById('ongoing-services-table').innerHTML = `<tr><td colspan="4">Erro ao carregar dados.</td></tr>`;
    });

    const alignmentQuery = query(
        collection(db, ALIGNMENT_COLLECTION_PATH),
        where('status', 'in', [STATUS_WAITING, STATUS_ATTENDING, STATUS_WAITING_GS, STATUS_READY])
    );

    onSnapshot(alignmentQuery, (snapshot) => {
        alignmentQueue = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        renderDisplay();
    }, (error) => {
        console.error("Erro ao ouvir fila de alinhamento:", error);
        document.getElementById('ongoing-services-table').innerHTML += `<tr><td colspan="4">Erro ao carregar dados.</td></tr>`;
    });
}

/**
 * Orquestra a renderização da tela, unindo e ordenando os dados.
 */
function renderDisplay() {
    // 1. Unifica e processa os dados para exibição, tratando duplicidades
    const combinedItems = new Map();
    const readyItems = [];

    // Processa carros da fila de alinhamento
    alignmentQueue.forEach(car => {
        if (car.status === STATUS_READY) {
            readyItems.push({ plate: car.licensePlate, client: car.clientName || 'N/A', service: 'Alinhamento' });
            return;
        }

        let priority = 99;
        let statusText = "Na fila";
        if (car.status === STATUS_ATTENDING) { priority = 1; statusText = "Alinhando"; }
        else if (car.status === STATUS_WAITING) { priority = 2; statusText = "Aguardando Alinhamento"; }
        else if (car.status === STATUS_WAITING_GS) { priority = 3; statusText = "Aguardando Serviço Geral"; }

        combinedItems.set(car.licensePlate, {
            plate: car.licensePlate,
            client: car.clientName || 'N/A',
            service: 'Alinhamento',
            status: statusText,
            priority,
            statusClass: car.status === STATUS_ATTENDING ? 'in-progress' : 'waiting'
        });
    });

    // Processa carros da fila de serviços gerais
    serviceJobs.forEach(job => {
        if (job.status === STATUS_READY) {
            readyItems.push({ plate: job.licensePlate, client: job.clientName || 'N/A', service: 'Serviço Geral' });
            return;
        }

        // Se o carro já está na lista (veio do alinhamento), não o substitua,
        // pois o status de alinhamento tem prioridade de exibição.
        if (job.status === STATUS_PENDING && !combinedItems.has(job.licensePlate)) {
            const serviceText = (job.statusGS === 'Pendente' && job.statusTS === 'Pendente')
                ? "Serviço Geral e Pneus"
                : (job.statusGS === 'Pendente' ? "Serviço Geral" : "Serviço de Pneus");
            
            combinedItems.set(job.licensePlate, { plate: job.licensePlate, client: job.clientName || 'N/A', service: serviceText, status: 'Em Andamento', priority: 5, statusClass: 'in-progress' });
        }
    });

    // Converte o Map para um array
    const displayItems = Array.from(combinedItems.values());

    // 2. Ordena a fila principal (RF002)
    displayItems.sort((a, b) => a.priority - b.priority);

    // 3. Renderiza as listas
    renderServiceList(displayItems);
    renderReadyList(readyItems);
}

/**
 * Renderiza a lista de serviços em andamento.
 * @param {Array} items - A lista de itens para exibir.
 */
function renderServiceList(items) {
    const tableBody = document.getElementById('ongoing-services-table');
    if (items.length === 0) {
        tableBody.innerHTML = `<tr><td colspan="4" style="text-align: center; padding: 2rem;">Nenhum veículo em atendimento.</td></tr>`;
        return;
    }
    tableBody.innerHTML = items.map((item, index) => `
        <tr>
            <td><div class="queue-position">${index + 1}º</div></td>
            <td>${item.plate}</td>
            <td>${item.service}</td>
            <td><span class="status-badge ${item.statusClass}">${item.status}</span></td>
        </tr>
    `).join('');
}

/**
 * Renderiza a lista de serviços concluídos.
 * @param {Array} items - A lista de itens prontos.
 */
function renderReadyList(items) {
    const tableBody = document.getElementById('completed-services-table');
    tableBody.innerHTML = items.map(item => `
        <tr>
            <td>${item.plate}</td>
            <td>${item.service}</td>
            <td><span class="status-badge ready">Pronto</span></td>
        </tr>
    `).join('');
}

/**
 * NOVO: Gerencia a rolagem automática da lista de serviços.
 */
function handleAutoScroll() {
    // A rolagem automática foi desativada para o novo layout,
    // pois cada tabela tem sua própria rolagem interna se necessário.
}

// =========================================================================
// NOVO: LÓGICA DE EXIBIÇÃO DE ANÚNCIOS (RF005, RF006, RF010)
// =========================================================================

/**
 * Busca a lista de anúncios ativos da API de marketing.
 */
async function fetchAds() {
    try {
        const response = await fetch(`${API_BASE_URL}/media`);
        if (!response.ok) {
            throw new Error('Falha ao buscar mídias da API.');
        }
        const mediaItems = await response.json();
        // Filtra apenas os ativos e mapeia para o formato esperado
        ads = mediaItems
            .filter(item => item.status === 'ativo')
            .map(item => ({ ...item, type: item.type === 'Imagem' ? 'image' : 'video' }))
            .sort((a, b) => (a.order || 99) - (b.order || 99)); // Ordena pela ordem definida

        console.log(`Anúncios ativos carregados via API: ${ads.length}`);
    } catch (error) {
        console.error("Erro ao buscar anúncios da API:", error);
        ads = []; // Garante que a lista de anúncios fique vazia em caso de erro (RF010)
    }
}

/**
 * Inicia o ciclo que agenda a exibição de anúncios.
 */
function startAdCycle() {
    // Limpa qualquer agendamento anterior para evitar duplicatas
    if (adCycleTimeout) {
        clearTimeout(adCycleTimeout);
    }
    // Agenda a próxima exibição de anúncio
    adCycleTimeout = setTimeout(showNextAd, CYCLE_INTERVAL);
    console.log(`Ciclo iniciado. Próxima troca em ${CYCLE_INTERVAL / 1000} segundos.`);
}

/**
 * Exibe o próximo anúncio da lista.
 */
function showNextAd() {
    // RF010: Se não houver anúncios, simplesmente reagenda e continua exibindo a fila.
    if (ads.length === 0) {
        console.warn("Nenhum anúncio para exibir. Reagendando ciclo.");
        startAdCycle();
        return;
    }

    // Seleciona o próximo anúncio em formato de rodízio
    const ad = ads[currentAdIndex];
    currentAdIndex = (currentAdIndex + 1) % ads.length;

    // Para a rolagem da fila e esconde o container
    if (scrollInterval) clearInterval(scrollInterval);
    if (adDisplayTimeout) clearTimeout(adDisplayTimeout); // Limpa timer anterior
    queueContainer.classList.add('fade-hidden'); // Inicia o fade-out da fila

    setTimeout(() => { // Aguarda a transição para trocar os conteúdos
        queueContainer.classList.add('hidden');
        adContainer.innerHTML = ''; // Limpa anúncios anteriores
        adContainer.classList.remove('hidden', 'fade-hidden');

        let adElement;
        if (ad.type === 'video') {
            const video = document.createElement('video'); // RF005
            video.src = ad.url;
            video.autoplay = true;
            video.muted = true; // Autoplay com som geralmente é bloqueado
            video.playsInline = true;
            video.loop = true; // Garante que o vídeo continue se for curto
            adElement = video;
        } else { // 'image'
            const img = document.createElement('img'); // RF005
            img.src = ad.url;
            adElement = img;
        }
        adContainer.appendChild(adElement);
        // Volta para a fila após o tempo fixo de 30 segundos
        adDisplayTimeout = setTimeout(hideAdAndResume, CYCLE_INTERVAL);
    }, 400); // Tempo da transição em ms
}

/**
 * Esconde o anúncio, volta a exibir a fila e reinicia o ciclo.
 */
function hideAdAndResume() {
    adContainer.classList.add('fade-hidden'); // Inicia o fade-out do anúncio
    setTimeout(() => {
        adContainer.classList.add('hidden'); // Esconde o container do anúncio
        queueContainer.classList.remove('hidden', 'fade-hidden');
        // handleAutoScroll(); // Rolagem não é mais necessária no novo layout
        startAdCycle(); // Reagenda o próximo anúncio
    }, 400); // Tempo da transição em ms
}

// --- Inicialização ---
document.addEventListener('DOMContentLoaded', () => {
    waitForFirebaseAuth(); // Inicia diretamente a verificação do Firebase.
});